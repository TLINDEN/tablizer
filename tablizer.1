.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TABLIZER 1"
.TH TABLIZER 1 "2025-03-06" "1" "User Commands"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
tablizer \- Manipulate tabular output of other programs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    Usage:
\&      tablizer [regex,...] [file, ...] [flags]
\&    
\&    Operational Flags:
\&      \-c, \-\-columns string              Only show the speficied columns (separated by ,)
\&      \-v, \-\-invert\-match                select non\-matching rows
\&      \-n, \-\-numbering                   Enable header numbering
\&      \-N, \-\-no\-color                    Disable pattern highlighting
\&      \-H, \-\-no\-headers                  Disable headers display
\&      \-s, \-\-separator string            Custom field separator
\&      \-k, \-\-sort\-by int|name            Sort by column (default: 1)
\&      \-z, \-\-fuzzy                       Use fuzzy search [experimental]
\&      \-F, \-\-filter field[!]=reg         Filter given field with regex, can be used multiple times
\&      \-T, \-\-transpose\-columns string    Transpose the speficied columns (separated by ,)
\&      \-R, \-\-regex\-transposer /from/to/  Apply /search/replace/ regexp to fields given in \-T
\&
\&    Output Flags (mutually exclusive):
\&      \-X, \-\-extended                    Enable extended output
\&      \-M, \-\-markdown                    Enable markdown table output
\&      \-O, \-\-orgtbl                      Enable org\-mode table output
\&      \-S, \-\-shell                       Enable shell evaluable output
\&      \-Y, \-\-yaml                        Enable yaml output
\&      \-C, \-\-csv                         Enable CSV output
\&      \-A, \-\-ascii                       Default output mode, ascii tabular
\&      \-L, \-\-hightlight\-lines            Use alternating background colors for tables
\&      \-y, \-\-yank\-columns                Yank specified columns (separated by ,) to clipboard,
\&                                        space separated
\&
\&    Sort Mode Flags (mutually exclusive):
\&      \-a, \-\-sort\-age                    sort according to age (duration) string
\&      \-D, \-\-sort\-desc                   Sort in descending order (default: ascending)
\&      \-i, \-\-sort\-numeric                sort according to string numerical value
\&      \-t, \-\-sort\-time                   sort according to time string
\&
\&    Other Flags:
\&          \-\-completion <shell>         Generate the autocompletion script for <shell>
\&      \-f, \-\-config <file>              Configuration file (default: ~/.config/tablizer/config)
\&      \-d, \-\-debug                      Enable debugging
\&      \-h, \-\-help                       help for tablizer
\&      \-m, \-\-man                        Display manual page
\&      \-V, \-\-version                    Print program version
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Many  programs generate  tabular output.   But sometimes  you need  to
post-process these tables, you may need  to remove one or more columns
or you  may want to filter  for some pattern (See  \s-1PATTERNS\s0) or you
may need the  output in another program and need  to parse it somehow.
Standard unix tools such as \fBawk\fR\|(1), \fBgrep\fR\|(1) or \fBcolumn\fR\|(1) may help, but
sometimes it's a tedious business.
.PP
Let's take  the output of  the tool  kubectl.  It contains  cells with
withespace and they do not separate columns by \s-1TAB\s0 characters. This is
not easy to process.
.PP
You can use \fBtablizer\fR to do these and more things.
.PP
\&\fBtablizer\fR  analyses the  header  fields of  a  table, registers  the
column positions of  each header field and separates  columns by those
positions.
.PP
Without any options it reads its input from \f(CW\*(C`STDIN\*(C'\fR, but you can also
specify a  file as a  parameter. If you want  to reduce the  output by
some regular expression,  just specify it as its  first parameter. You
may also  use the  \fB\-v\fR option  to exclude all  rows which  match the
pattern. Hence:
.PP
.Vb 2
\&   # read from STDIN
\&   kubectl get pods | tablizer
\&
\&   # read a file
\&   tablizer filename
\&
\&   # search for pattern in a file (works like grep)
\&   tablizer regex filename
\&
\&   # search for pattern in STDIN
\&   kubectl get pods | tablizer regex
.Ve
.PP
The output  looks like the  original one  but every header  field will
have a numer associated with it, e.g.:
.PP
.Vb 1
\&   NAME(1) READY(2) STATUS(3) RESTARTS(4) AGE(5)
.Ve
.PP
These numbers denote the column and  you can use them to specify which
columns you want to have in your output (see \s-1COLUMNS\s0:
.PP
.Vb 1
\&   kubectl get pods | tablizer \-c1,3
.Ve
.PP
You can specify the numbers in any order but output will always follow
the original order.
.PP
The numbering can be suppressed by using the \fB\-n\fR option.
.PP
By  default tablizer  shows  a  header containing  the  names of  each
column.  This can  be disabled using the \fB\-H\fR option.   Be aware that
this only affects tabular output modes.  Shell, Extended, Yaml and \s-1CSV\s0
output modes always use the column names.
.PP
By  default, if  a  \fBpattern\fR  has been  speficied,  matches will  be
highlighted. You can disable this behavior with the \fB\-N\fR option.
.PP
Use the  \fB\-k\fR option to specify  by which column to  sort the tabular
data  (as in  \s-1GNU\s0  \fBsort\fR\|(1)).  The default  sort  column  is the  first
one. You can specify column numbers or names. Column numbers start
with 1, names are case insensitive. You can specify multiple columns
separated by comma to sort, but the type must be the same. For example
if you want to sort numerically, all columns must be numbers. If you
use column numbers, then be aware, that these are the numbers before
column extraction. For example if you have a table with 4 columns and
specify \f(CW\*(C`\-c4\*(C'\fR, then only 1 column (the fourth) will be printed,
however if you want to sort by this column, you'll have to specify
\&\f(CW\*(C`\-k4\*(C'\fR.
.PP
The default  sort order  is ascending.  You can  change this  to
descending order using the option \fB\-D\fR.  The default sort order is by
alphanumeric string, but there are other sort modes:
.IP "\fB\-a \-\-sort\-age\fR" 4
.IX Item "-a --sort-age"
Sorts duration strings like \*(L"1d4h32m51s\*(R".
.IP "\fB\-i \-\-sort\-numeric\fR" 4
.IX Item "-i --sort-numeric"
Sorts numeric fields.
.IP "\fB\-t \-\-sort\-time\fR" 4
.IX Item "-t --sort-time"
Sorts timestamps.
.PP
Finally the  \fB\-d\fR option  enables debugging  output which  is mostly
useful for the developer.
.SS "\s-1PATTERNS AND FILTERING\s0"
.IX Subsection "PATTERNS AND FILTERING"
You can reduce  the rows being displayed by using  one or more regular
expression patterns.   The regexp  language being used  is the  one of
\&\s-1GOLANG,\s0     refer    to     the    syntax     cheat    sheet     here:
<https://pkg.go.dev/regexp/syntax>.
.PP
If you  want to  read a more  comprehensive documentation  about the
topic and have perl installed you can read it with:
.PP
.Vb 1
\&    perldoc perlre
.Ve
.PP
Or read it online: <https://perldoc.perl.org/perlre>. But please note
that the \s-1GO\s0 regexp engine does \s-1NOT\s0 support all perl regex terms,
especially look-ahead and look-behind.
.PP
If you want to supply flags to a regex, then surround it with slashes
and append the flag. The following flags are supported:
.PP
.Vb 2
\&    i => case insensitive
\&    ! => negative match
.Ve
.PP
Example for a case insensitive search:
.PP
.Vb 1
\&    kubectl get pods \-A | tablizer "/account/i"
.Ve
.PP
If you use the \f(CW\*(C`!\*(C'\fR flag, then the regex match will be negated, that
is, if a line in the input matches the given regex, but \f(CW\*(C`!\*(C'\fR is
supplied, tablizer will \s-1NOT\s0 include it in the output.
.PP
For example, here we want to get all lines matching \*(L"foo\*(R" but not
\&\*(L"bar\*(R":
.PP
.Vb 1
\&    cat table | tablizer foo \*(Aq/bar/!\*(Aq
.Ve
.PP
This would match a line \*(L"foo zorro\*(R" but not \*(L"foo bar\*(R".
.PP
The flags can also be combined.
.PP
You  can also use  the experimental  fuzzy search  feature by  providing the
option \fB\-z\fR, in which case the  pattern is regarded as a fuzzy search
term, not a regexp.
.PP
Sometimes you want to  filter by one or more columns.  You can do that
using the \fB\-F\fR option. The option can be specified multiple times and
has the following format:
.PP
.Vb 1
\&    fieldname=regexp
.Ve
.PP
Fieldnames (== columns headers) are case insensitive.
.PP
If you specify more than one filter, both filters have to match (\s-1AND\s0
operation).
.PP
These field filters can also be negated:
.PP
.Vb 1
\&    fieldname!=regexp
.Ve
.PP
If the option \fB\-v\fR is specified, the filtering is inverted.
.SS "\s-1COLUMNS\s0"
.IX Subsection "COLUMNS"
The  parameter  \fB\-c\fR  can  be  used  to  specify,  which  columns  to
display.  By default  tablizer numerizes  the header  names and  these
numbers can  be used to specify  which header to display,  see example
above.
.PP
However, beside  numbers, you  can also  use regular  expressions with
\&\fB\-c\fR, also  separated by comma. And  you can mix column  numbers with
regexps.
.PP
Lets take this table:
.PP
.Vb 4
\&        PID TTY          TIME CMD
\&      14001 pts/0    00:00:00 bash
\&      42871 pts/0    00:00:00 ps
\&      42872 pts/0    00:00:00 sed
.Ve
.PP
We want to see only the \s-1CMD\s0 column and use a regex for this:
.PP
.Vb 6
\&    ps | tablizer \-s \*(Aq\es+\*(Aq \-c C
\&    CMD(4)
\&    bash
\&    ps
\&    tablizer
\&    sed
.Ve
.PP
where \*(L"C\*(R" is our regexp which matches \s-1CMD.\s0
.PP
If a column specifier doesn't look like a regular expression, matching
against header  fields will  be case  insensitive. So,  if you  have a
field with  the name \f(CW\*(C`ID\*(C'\fR then  these will all match:  \f(CW\*(C`\-c id\*(C'\fR, \f(CW\*(C`\-c
Id\*(C'\fR. The same rule applies to the options \f(CW\*(C`\-T\*(C'\fR and \f(CW\*(C`\-F\*(C'\fR.
.SS "\s-1TRANSPOSE FIELDS USING REGEXPS\s0"
.IX Subsection "TRANSPOSE FIELDS USING REGEXPS"
You can manipulate field contents using regular expressions. You have
to tell tablizer which field[s] to operate on using the option \f(CW\*(C`\-T\*(C'\fR
and the search/replace pattern using \f(CW\*(C`\-R\*(C'\fR. The number of columns and
patterns must match.
.PP
A search/replace pattern consists of the following elements:
.PP
.Vb 1
\&    /search\-regexp/replace\-string/
.Ve
.PP
The separator can be any valid character. Especially if you want to
use a regexp containing the \f(CW\*(C`/\*(C'\fR character, eg:
.PP
.Vb 1
\&    |search\-regexp|replace\-string|
.Ve
.PP
Example:
.PP
.Vb 7
\&    cat t/testtable2
\&    NAME  DURATION
\&    x     10
\&    a     100
\&    z     0
\&    u     4
\&    k     6
\&    
\&    cat t/testtable2 | tablizer \-T2 \-R \*(Aq/^\ed/4/\*(Aq \-n
\&    NAME    DURATION 
\&    x       40      
\&    a       400     
\&    z       4       
\&    u       4       
\&    k       4
.Ve
.SS "\s-1OUTPUT MODES\s0"
.IX Subsection "OUTPUT MODES"
There might be cases  when the tabular output of a  program is way too
large  for your  current  terminal but  you still  need  to see  every
column.   In such  cases the  \fB\-o extended\fR  or \fB\-X\fR  option can  be
useful which enables \fIextended mode\fR. In  this mode, each row will be
printed vertically,  header left,  value right,  aligned by  the field
widths. Here's an example:
.PP
.Vb 6
\&    kubectl get pods | ./tablizer \-o extended
\&        NAME: repldepl\-7bcd8d5b64\-7zq4l  
\&       READY: 1/1    
\&      STATUS: Running  
\&    RESTARTS: 1 (71m ago)  
\&         AGE: 5h28m
.Ve
.PP
You can  of course  still use  a regex  to reduce  the number  of rows
displayed.
.PP
The option \fB\-o shell\fR  can be used if the output  has to be processed
by the shell,  it prints variable assignments for each  cell, one line
per row:
.PP
.Vb 4
\&    kubectl get pods | ./tablizer \-o extended ./tablizer \-o shell
\&    NAME="repldepl\-7bcd8d5b64\-7zq4l" READY="1/1" STATUS="Running" RESTARTS="9 (47m ago)" AGE="4d23h" 
\&    NAME="repldepl\-7bcd8d5b64\-m48n8" READY="1/1" STATUS="Running" RESTARTS="9 (47m ago)" AGE="4d23h" 
\&    NAME="repldepl\-7bcd8d5b64\-q2bf4" READY="1/1" STATUS="Running" RESTARTS="9 (47m ago)" AGE="4d23h"
.Ve
.PP
You can use this in an eval loop.
.PP
Beside normal  ascii mode  (the default) and  extended mode  there are
more output modes available: \fBorgtbl\fR  which prints an Emacs org-mode
table and  \fBmarkdown\fR which prints  a Markdown table,  \fByaml\fR, which
prints  yaml encoding  and \s-1CSV\s0  mode, which  prints a  comma separated
value file.
.SS "\s-1PUT FIELDS TO CLIPBOARD\s0"
.IX Subsection "PUT FIELDS TO CLIPBOARD"
You can let tablizer put fields to the clipboard using the option
\&\f(CW\*(C`\-y\*(C'\fR. This best fits the use-case when the result of your filtering
yields just one row. For example:
.PP
.Vb 1
\&    cloudctl cluster ls | tablizer \-yid matchbox
.Ve
.PP
If \*(L"matchbox\*(R" matches one cluster, you can immediately use the id of
that cluster somewhere else and paste it. Of course, if there are
multiple matches, then all id's will be put into the clipboard
separated by one space.
.SS "\s-1ENVIRONMENT VARIABLES\s0"
.IX Subsection "ENVIRONMENT VARIABLES"
\&\fBtablizer\fR supports  certain environment variables which  use can use
to  influence   program  behavior.   Commandline  flags   have  always
precedence over environment variables.
.IP "<T_HEADER_NUMBERING> \- enable numbering of header fields, like \fB\-n\fR." 4
.IX Item "<T_HEADER_NUMBERING> - enable numbering of header fields, like -n."
.PD 0
.IP "<T_COLUMNS> \- comma separated list of columns to output, like \fB\-c\fR" 4
.IX Item "<T_COLUMNS> - comma separated list of columns to output, like -c"
.IP "<\s-1NO_COLORS\s0> \- disable colorization of matches, like \fB\-N\fR" 4
.IX Item "<NO_COLORS> - disable colorization of matches, like -N"
.PD
.SS "\s-1COMPLETION\s0"
.IX Subsection "COMPLETION"
Shell completion for command line options  can be enabled by using the
\&\fB\-\-completion\fR  flag. The  required  parameter is  the  name of  your
shell. Currently supported are: bash, zsh, fish and powershell.
.PP
Detailed instructions:
.IP "Bash:" 4
.IX Item "Bash:"
.Vb 1
\&   source <(tablizer \-\-completion bash)
.Ve
.Sp
To load completions for each session, execute once:
.Sp
.Vb 2
\&  # Linux:
\&  $ tablizer \-\-completion bash > /etc/bash_completion.d/tablizer
\&
\&  # macOS:
\&  $ tablizer \-\-completion bash > $(brew \-\-prefix)/etc/bash_completion.d/tablizer
.Ve
.IP "Zsh:" 4
.IX Item "Zsh:"
If shell completion is not already enabled in your environment,
you will need to enable it.  You can execute the following once:
.Sp
.Vb 1
\&  echo "autoload \-U compinit; compinit" >> ~/.zshrc
.Ve
.Sp
To load completions for each session, execute once:
.Sp
.Vb 1
\&  $ tablizer \-\-completion zsh > "${fpath[1]}/_tablizer"
.Ve
.Sp
You will need to start a new shell for this setup to take effect.
.IP "fish:" 4
.IX Item "fish:"
.Vb 1
\&   tablizer \-\-completion fish | source
.Ve
.Sp
To load completions for each session, execute once:
.Sp
.Vb 1
\&   tablizer \-\-completion fish > ~/.config/fish/completions/tablizer.fish
.Ve
.IP "PowerShell:" 4
.IX Item "PowerShell:"
.Vb 1
\&   tablizer \-\-completion powershell | Out\-String | Invoke\-Expression
.Ve
.Sp
To load completions for every new session, run:
.Sp
.Vb 1
\&   tablizer \-\-completion powershell > tablizer.ps1
.Ve
.Sp
and source this file from your PowerShell profile.
.SH "CONFIGURATION AND COLORS"
.IX Header "CONFIGURATION AND COLORS"
YOu can put certain configuration values into a configuration file in
\&\s-1HCL\s0 format. By default tablizer looks for
\&\f(CW\*(C`$HOME/.config/tablizer/config\*(C'\fR, but you can provide one using the
parameter \f(CW\*(C`\-f\*(C'\fR.
.PP
In the configuration the following variables can be defined:
.PP
.Vb 8
\&    BG             = "lightGreen"
\&    FG             = "white"
\&    HighlightBG    = "lightGreen"
\&    HighlightFG    = "white"
\&    NoHighlightBG  = "white"
\&    NoHighlightFG  = "lightGreen"
\&    HighlightHdrBG = "red"
\&    HighlightHdrFG = "white"
.Ve
.PP
The following color definitions are available:
.PP
black, blue,  cyan, darkGray, default, green,  lightBlue, lightCyan,
lightGreen,   lightMagenta,   lightRed,   lightWhite,   lightYellow,
magenta, red, white, yellow
.PP
The Variables \fB\s-1FG\s0\fR and \fB\s-1BG\s0\fR are being used to highlight matches. The
other *FG and *BG variables are for colored table output (enabled with
the \f(CW\*(C`\-L\*(C'\fR parameter).
.PP
Colorization can be turned off completely either by setting the
parameter \f(CW\*(C`\-N\*(C'\fR or the environment variable \fB\s-1NO_COLOR\s0\fR to a true value.
.SH "BUGS"
.IX Header "BUGS"
In order to report a bug, unexpected behavior, feature requests
or to submit a patch, please open an issue on github:
<https://github.com/TLINDEN/tablizer/issues>.
.SH "LICENSE"
.IX Header "LICENSE"
This software is licensed under the \s-1GNU GENERAL PUBLIC LICENSE\s0 version 3.
.PP
Copyright (c) 2022\-2024 by Thomas von Dein
.PP
This software uses the following \s-1GO\s0 modules:
.IP "repr (https://github.com/alecthomas/repr)" 4
.IX Item "repr (https://github.com/alecthomas/repr)"
Released under the \s-1MIT\s0 License, Copyright (c) 2016 Alec Thomas
.IP "cobra (https://github.com/spf13/cobra)" 4
.IX Item "cobra (https://github.com/spf13/cobra)"
Released under the Apache 2.0 license, Copyright 2013\-2022 The Cobra Authors
.IP "dateparse (github.com/araddon/dateparse)" 4
.IX Item "dateparse (github.com/araddon/dateparse)"
Released under the \s-1MIT\s0 License, Copyright (c) 2015\-2017 Aaron Raddon
.IP "color (github.com/gookit/color)" 4
.IX Item "color (github.com/gookit/color)"
Released under the \s-1MIT\s0 License, Copyright (c) 2016 inhere
.IP "tablewriter (github.com/olekukonko/tablewriter)" 4
.IX Item "tablewriter (github.com/olekukonko/tablewriter)"
Released under the \s-1MIT\s0 License, Copyright (c) 201 by Oleku Konko
.IP "yaml (gopkg.in/yaml.v3)" 4
.IX Item "yaml (gopkg.in/yaml.v3)"
Released under the \s-1MIT\s0 License, Copyright (c) 2006\-2011 Kirill Simonov
.SH "AUTHORS"
.IX Header "AUTHORS"
Thomas von Dein \fBtom \s-1AT\s0 vondein \s-1DOT\s0 org\fR
