.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TABLIZER 1"
.TH TABLIZER 1 "2022-10-15" "1" "User Commands"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
tablizer \- Manipulate tabular output of other programs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    Usage:
\&      tablizer [regex] [file, ...] [flags]
\&    
\&    Flags:
\&      \-c, \-\-columns string     Only show the speficied columns (separated by ,)
\&      \-d, \-\-debug              Enable debugging
\&      \-h, \-\-help               help for tablizer
\&      \-v, \-\-invert\-match       select non\-matching rows
\&      \-m, \-\-man                Display manual page
\&      \-n, \-\-no\-numbering       Disable header numbering
\&      \-N, \-\-no\-color           Disable pattern highlighting
\&      \-o, \-\-output string      Output mode \- one of: orgtbl, markdown, extended, ascii(default)
\&      \-X, \-\-extended           Enable extended output
\&      \-M, \-\-markdown           Enable markdown table output
\&      \-O, \-\-orgtbl             Enable org\-mode table output
\&      \-s, \-\-separator string   Custom field separator
\&      \-k, \-\-sort\-by int        Sort by column (default: 1)
\&      \-D, \-\-sort\-desc          Sort in descending order (default: ascending)
\&      \-v, \-\-version            Print program version
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Many  programs generate  tabular output.   But sometimes  you need  to
post-process these tables, you may need  to remove one or more columns
or you  may want to filter  for some pattern (See  \s-1PATTERNS\s0) or you
may need the  output in another program and need  to parse it somehow.
Standard unix tools such as \fBawk\fR\|(1), \fBgrep\fR\|(1) or \fBcolumn\fR\|(1) may help, but
sometimes it's a tedious business.
.PP
Let's take  the output of  the tool  kubectl.  It contains  cells with
withespace and they do not separate columns by \s-1TAB\s0 characters. This is
not easy to process.
.PP
You can use \fBtablizer\fR to do these and more things.
.PP
\&\fBtablizer\fR  analyses the  header  fields of  a  table, registers  the
column positions of  each header field and separates  columns by those
positions.
.PP
Without any options it reads its input from \f(CW\*(C`STDIN\*(C'\fR, but you can also
specify a  file as a  parameter. If you want  to reduce the  output by
some regular expression,  just specify it as its  first parameter. You
may also  use the  \fB\-v\fR option  to exclude all  rows which  match the
pattern. Hence:
.PP
.Vb 2
\&   # read from STDIN
\&   kubectl get pods | tablizer
\&
\&   # read a file
\&   tablizer filename
\&
\&   # search for pattern in a file (works like grep)
\&   tablizer regex filename
\&
\&   # search for pattern in STDIN
\&   kubectl get pods | tablizer regex
.Ve
.PP
The output  looks like the  original one  but every header  field will
have a numer associated with it, e.g.:
.PP
.Vb 1
\&   NAME(1) READY(2) STATUS(3) RESTARTS(4) AGE(5)
.Ve
.PP
These numbers denote the column and  you can use them to specify which
columns you want to have in your output (see \s-1COLUMNS\s0:
.PP
.Vb 1
\&   kubectl get pods | tablizer \-c1,3
.Ve
.PP
You can specify the numbers in any order but output will always follow
the original order.
.PP
The numbering can be suppressed by using the \fB\-n\fR option.
.PP
By  default, if  a  \fBpattern\fR  has been  speficied,  matches will  be
highlighted. You can disable this behavior with the \fB\-N\fR option.
.PP
Use the  \fB\-k\fR option to specify  by which column to  sort the tabular
data (as in \s-1GNU\s0 \fBsort\fR\|(1)). The default sort column is the first one. To
disable sorting at all, supply 0  (Zero) to \-k. The default sort order
is ascending. You can change this to descending order using the option
\&\fB\-D\fR.
.PP
Finally the  \fB\-d\fR option  enables debugging  output which  is mostly
useful for the developer.
.SS "\s-1PATTERNS\s0"
.IX Subsection "PATTERNS"
You can reduce the rows being  displayed by using a regular expression
pattern.  The  regexp is  \s-1PCRE\s0 compatible, refer  to the  syntax cheat
sheet here: <https://github.com/google/re2/wiki/Syntax>.  If you want
to read  a more comprehensive  documentation about the topic  and have
perl installed you can read it with:
.PP
.Vb 1
\&    perldoc perlre
.Ve
.PP
Or read it online: <https://perldoc.perl.org/perlre>.
.PP
A note on  modifiers: the regexp engine used in  tablizer uses another
modifier syntax:
.PP
.Vb 1
\&    (?MODIFIER)
.Ve
.PP
The most important modifiers are:
.PP
\&\f(CW\*(C`i\*(C'\fR ignore case
\&\f(CW\*(C`m\*(C'\fR multiline mode
\&\f(CW\*(C`s\*(C'\fR single line mode
.PP
Example for a case insensitive search:
.PP
.Vb 1
\&    kubectl get pods \-A | tablizer "(?i)account"
.Ve
.SS "\s-1COLUMNS\s0"
.IX Subsection "COLUMNS"
The  parameter  \fB\-c\fR  can  be  used  to  specify,  which  columns  to
display.  By default  tablizer numerizes  the header  names and  these
numbers can  be used to specify  which header to display,  see example
above.
.PP
However, beside  numbers, you  can also  use regular  expressions with
\&\fB\-c\fR, also  separated by comma. And  you can mix column  numbers with
regexps.
.PP
Lets take this table:
.PP
.Vb 4
\&        PID TTY          TIME CMD
\&      14001 pts/0    00:00:00 bash
\&      42871 pts/0    00:00:00 ps
\&      42872 pts/0    00:00:00 sed
.Ve
.PP
We want to see only the \s-1CMD\s0 column and use a regex for this:
.PP
.Vb 6
\&    ps | tablizer \-s \*(Aq\es+\*(Aq \-c C
\&    CMD(4)
\&    bash
\&    ps
\&    tablizer
\&    sed
.Ve
.PP
where \*(L"C\*(R" is our regexp which matches \s-1CMD.\s0
.SS "\s-1OUTPUT MODES\s0"
.IX Subsection "OUTPUT MODES"
There might be cases  when the tabular output of a  program is way too
large  for your  current  terminal but  you still  need  to see  every
column.   In such  cases the  \fB\-o extended\fR  or \fB\-X\fR  option can  be
useful which enables \fIextended mode\fR. In  this mode, each row will be
printed vertically,  header left,  value right,  aligned by  the field
widths. Here's an example:
.PP
.Vb 6
\&    kubectl get pods | ./tablizer \-o extended
\&        NAME: repldepl\-7bcd8d5b64\-7zq4l  
\&       READY: 1/1    
\&      STATUS: Running  
\&    RESTARTS: 1 (71m ago)  
\&         AGE: 5h28m
.Ve
.PP
You can  of course  still use  a regex  to reduce  the number  of rows
displayed.
.PP
The option \fB\-o shell\fR  can be used if the output  has to be processed
by the shell,  it prints variable assignments for each  cell, one line
per row:
.PP
.Vb 4
\&    kubectl get pods | ./tablizer \-o extended ./tablizer \-o shell
\&    NAME="repldepl\-7bcd8d5b64\-7zq4l" READY="1/1" STATUS="Running" RESTARTS="9 (47m ago)" AGE="4d23h" 
\&    NAME="repldepl\-7bcd8d5b64\-m48n8" READY="1/1" STATUS="Running" RESTARTS="9 (47m ago)" AGE="4d23h" 
\&    NAME="repldepl\-7bcd8d5b64\-q2bf4" READY="1/1" STATUS="Running" RESTARTS="9 (47m ago)" AGE="4d23h"
.Ve
.PP
You can use this in an eval loop.
.PP
Beside normal  ascii mode  (the default) and  extended mode  there are
more output modes available: \fBorgtbl\fR  which prints an Emacs org-mode
table and \fBmarkdown\fR which prints a Markdown table.
.SH "BUGS"
.IX Header "BUGS"
In order to report a bug, unexpected behavior, feature requests
or to submit a patch, please open an issue on github:
<https://github.com/TLINDEN/tablizer/issues>.
.SH "LICENSE"
.IX Header "LICENSE"
This software is licensed under the \s-1GNU GENERAL PUBLIC LICENSE\s0 version 3.
.PP
Copyright (c) 2022 by Thomas von Dein
.PP
This software uses the following \s-1GO\s0 libraries:
.IP "repr (https://github.com/alecthomas/repr)" 4
.IX Item "repr (https://github.com/alecthomas/repr)"
Released under the \s-1MIT\s0 License, Copyright (c) 2016 Alec Thomas
.IP "cobra (https://github.com/spf13/cobra)" 4
.IX Item "cobra (https://github.com/spf13/cobra)"
Released under the Apache 2.0 license, Copyright 2013\-2022 The Cobra Authors
.SH "AUTHORS"
.IX Header "AUTHORS"
Thomas von Dein \fBtom \s-1AT\s0 vondein \s-1DOT\s0 org\fR
